/**
 * @monogrid/gainmap-js v3.4.0
 * With ❤️, by MONOGRID <gainmap@monogrid.com>
 */
import{ClampToEdgeWrapping as e,LinearFilter as r,Scene as t,OrthographicCamera as i,HalfFloatType as s,FloatType as a,Mesh as n,PlaneGeometry as h,WebGLRenderTarget as o,RGBAFormat as d,UVMapping as p,WebGLRenderer as _,DataTexture as g,LinearSRGBColorSpace as l,ShaderMaterial as c,Texture as w,MeshBasicMaterial as m,IntType as T,ShortType as u,ByteType as y,UnsignedIntType as f,UnsignedByteType as O}from"three";const b=(e,r,t)=>{let i;switch(e){case O:i=new Uint8ClampedArray(r*t*4);break;case s:i=new Uint16Array(r*t*4);break;case f:i=new Uint32Array(r*t*4);break;case y:i=new Int8Array(r*t*4);break;case u:i=new Int16Array(r*t*4);break;case T:i=new Int32Array(r*t*4);break;case a:i=new Float32Array(r*t*4);break;default:throw new Error("Unsupported data type")}return i};let v;class R{_renderer;_rendererIsDisposable=!1;_material;_scene;_camera;_quad;_renderTarget;_width;_height;_type;_colorSpace;_supportsReadPixels=!0;constructor(_){this._width=_.width,this._height=_.height,this._type=_.type,this._colorSpace=_.colorSpace;const g={format:d,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:void 0!==_.renderTargetOptions?.anisotropy?_.renderTargetOptions?.anisotropy:1,generateMipmaps:void 0!==_.renderTargetOptions?.generateMipmaps&&_.renderTargetOptions?.generateMipmaps,magFilter:void 0!==_.renderTargetOptions?.magFilter?_.renderTargetOptions?.magFilter:r,minFilter:void 0!==_.renderTargetOptions?.minFilter?_.renderTargetOptions?.minFilter:r,samples:void 0!==_.renderTargetOptions?.samples?_.renderTargetOptions?.samples:void 0,wrapS:void 0!==_.renderTargetOptions?.wrapS?_.renderTargetOptions?.wrapS:e,wrapT:void 0!==_.renderTargetOptions?.wrapT?_.renderTargetOptions?.wrapT:e};if(this._material=_.material,_.renderer?this._renderer=_.renderer:(this._renderer=R.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new t,this._camera=new i,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!((e,r,t,i)=>{if(void 0!==v)return v;const s=new o(1,1,i);r.setRenderTarget(s);const a=new n(new h,new m({color:16777215}));r.render(a,t),r.setRenderTarget(null);const d=b(e,s.width,s.height);return r.readRenderTargetPixels(s,0,0,s.width,s.height,d),s.dispose(),a.geometry.dispose(),a.material.dispose(),v=0!==d[0],v})(this._type,this._renderer,this._camera,g)){let e;if(this._type===s)e=this._renderer.extensions.has("EXT_color_buffer_float")?a:void 0;void 0!==e?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${a}`),this._type=e):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new n(new h,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new o(this.width,this.height,g),this._renderTarget.texture.mapping=void 0!==_.renderTargetOptions?.mapping?_.renderTargetOptions?.mapping:p}static instantiateRenderer(){const e=new _;return e.setSize(128,128),e}render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(e){throw this._renderer.setRenderTarget(null),e}this._renderer.setRenderTarget(null)};toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=b(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(t){const i=new g(this.toArray(),this.width,this.height,d,this._type,t?.mapping||p,t?.wrapS||e,t?.wrapT||e,t?.magFilter||r,t?.minFilter||r,t?.anisotropy||1,l);return i.generateMipmaps=void 0!==t?.generateMipmaps&&t?.generateMipmaps,i}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof c&&Object.values(this.material.uniforms).forEach(e=>{e.value instanceof w&&e.value.dispose()}),Object.values(this.material).forEach(e=>{e instanceof w&&e.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}export{R as Q};
