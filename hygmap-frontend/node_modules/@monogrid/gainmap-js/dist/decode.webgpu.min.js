/**
 * @monogrid/gainmap-js v3.4.0
 * With ❤️, by MONOGRID <gainmap@monogrid.com>
 */
import{c as e,L as t,e as r,X as i,G as s}from"./Loader-CKVwvejH.js";export{M as MPFExtractor,a as extractXMP}from"./Loader-CKVwvejH.js";import{ClampToEdgeWrapping as n,LinearFilter as o,Scene as h,OrthographicCamera as d,Mesh as p,PlaneGeometry as m,RenderTarget as g,RGBAFormat as f,UVMapping as l,WebGPURenderer as _,DataTexture as c,LinearSRGBColorSpace as u,ShaderMaterial as y,Texture as w,MeshBasicNodeMaterial as x,NoBlending as v,FileLoader as T}from"three/webgpu";import"three";import{vec3 as U,texture as R,uniform as S,pow as C,sub as O,float as b,add as D,mul as E,exp2 as H,max as F,min as q}from"three/tsl";class z{_renderer;_rendererIsDisposable=!1;_material;_scene;_camera;_quad;_renderTarget;_width;_height;_type;_colorSpace;_supportsReadPixels=!0;constructor(e){this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const t={format:f,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:void 0!==e.renderTargetOptions?.anisotropy?e.renderTargetOptions?.anisotropy:1,generateMipmaps:void 0!==e.renderTargetOptions?.generateMipmaps&&e.renderTargetOptions?.generateMipmaps,magFilter:void 0!==e.renderTargetOptions?.magFilter?e.renderTargetOptions?.magFilter:o,minFilter:void 0!==e.renderTargetOptions?.minFilter?e.renderTargetOptions?.minFilter:o,samples:void 0!==e.renderTargetOptions?.samples?e.renderTargetOptions?.samples:void 0,wrapS:void 0!==e.renderTargetOptions?.wrapS?e.renderTargetOptions?.wrapS:n,wrapT:void 0!==e.renderTargetOptions?.wrapT?e.renderTargetOptions?.wrapT:n};this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=z.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new h,this._camera=new d,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),this._quad=new p(new m,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new g(this.width,this.height,t),this._renderTarget.texture.mapping=void 0!==e.renderTargetOptions?.mapping?e.renderTargetOptions?.mapping:l}static instantiateRenderer(){const e=new _;return e.setSize(128,128),e}render=async()=>{this._renderer.hasInitialized()||await this._renderer.init(),this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(e){throw this._renderer.setRenderTarget(null),e}this._renderer.setRenderTarget(null)};async toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");return await this._renderer.readRenderTargetPixelsAsync(this._renderTarget,0,0,this._width,this._height)}async toDataTexture(e){const t=new c(await this.toArray(),this.width,this.height,f,this._type,e?.mapping||l,e?.wrapS||n,e?.wrapT||n,e?.magFilter||o,e?.minFilter||o,e?.anisotropy||1,u);return t.flipY=void 0===e?.flipY||e?.flipY,t.generateMipmaps=void 0!==e?.generateMipmaps&&e?.generateMipmaps,t}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&this._renderer.dispose()}dispose(e){e&&this.renderTarget.dispose(),this.material instanceof y&&Object.values(this.material.uniforms).forEach(e=>{e.value instanceof w&&e.value.dispose()}),Object.values(this.material).forEach(e=>{e instanceof w&&e.dispose()}),this.material.dispose(),this._quad.geometry.dispose(),this.disposeOnDemandRenderer()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const B=U(-65504,-65504,-65504),P=U(65504,65504,65504);class I extends x{_maxDisplayBoost;_hdrCapacityMin;_hdrCapacityMax;_gammaUniform;_offsetHdrUniform;_offsetSdrUniform;_gainMapMinUniform;_gainMapMaxUniform;_weightFactorUniform;_sdrTexture;_gainMapTexture;constructor({gamma:e,offsetHdr:t,offsetSdr:r,gainMapMin:a,gainMapMax:i,maxDisplayBoost:s,hdrCapacityMin:n,hdrCapacityMax:o,sdr:h,gainMap:d}){super(),this.name="GainMapDecoderMaterial",this.blending=v,this.depthTest=!1,this.depthWrite=!1,this._sdrTexture=R(h),this._gainMapTexture=R(d),this._gammaUniform=S(U(1/e[0],1/e[1],1/e[2])),this._offsetHdrUniform=S(U(t[0],t[1],t[2])),this._offsetSdrUniform=S(U(r[0],r[1],r[2])),this._gainMapMinUniform=S(U(a[0],a[1],a[2])),this._gainMapMaxUniform=S(U(i[0],i[1],i[2]));const p=(Math.log2(s)-n)/(o-n);this._weightFactorUniform=S(p),this._maxDisplayBoost=s,this._hdrCapacityMin=n,this._hdrCapacityMax=o;const m=this._sdrTexture.rgb,g=this._gainMapTexture.rgb,f=C(g,this._gammaUniform),l=O(b(1),f),_=D(E(this._gainMapMinUniform,l),E(this._gainMapMaxUniform,f)),c=O(E(D(m,this._offsetSdrUniform),H(E(_,this._weightFactorUniform))),this._offsetHdrUniform),u=F(B,q(P,c));this.colorNode=u}get sdr(){return this._sdrTexture.value}set sdr(e){this._sdrTexture.value=e}get gainMap(){return this._gainMapTexture.value}set gainMap(e){this._gainMapTexture.value=e}get offsetHdr(){return[this._offsetHdrUniform.value.x,this._offsetHdrUniform.value.y,this._offsetHdrUniform.value.z]}set offsetHdr(e){this._offsetHdrUniform.value.x=e[0],this._offsetHdrUniform.value.y=e[1],this._offsetHdrUniform.value.z=e[2]}get offsetSdr(){return[this._offsetSdrUniform.value.x,this._offsetSdrUniform.value.y,this._offsetSdrUniform.value.z]}set offsetSdr(e){this._offsetSdrUniform.value.x=e[0],this._offsetSdrUniform.value.y=e[1],this._offsetSdrUniform.value.z=e[2]}get gainMapMin(){return[this._gainMapMinUniform.value.x,this._gainMapMinUniform.value.y,this._gainMapMinUniform.value.z]}set gainMapMin(e){this._gainMapMinUniform.value.x=e[0],this._gainMapMinUniform.value.y=e[1],this._gainMapMinUniform.value.z=e[2]}get gainMapMax(){return[this._gainMapMaxUniform.value.x,this._gainMapMaxUniform.value.y,this._gainMapMaxUniform.value.z]}set gainMapMax(e){this._gainMapMaxUniform.value.x=e[0],this._gainMapMaxUniform.value.y=e[1],this._gainMapMaxUniform.value.z=e[2]}get gamma(){return[1/this._gammaUniform.value.x,1/this._gammaUniform.value.y,1/this._gammaUniform.value.z]}set gamma(e){this._gammaUniform.value.x=1/e[0],this._gammaUniform.value.y=1/e[1],this._gammaUniform.value.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this._weightFactorUniform.value=Math.max(0,Math.min(1,e))}}const L=e({renderer:_,createMaterial:e=>new I(e),createQuadRenderer:e=>new z(e)}),W=async e=>{if(!e.renderer)throw new Error("Renderer is required for decode function");const t=L({...e,renderer:e.renderer});try{await t.render()}catch(e){throw t.disposeOnDemandRenderer(),e}return t};class j extends t{constructor(e,t){super({renderer:e,createMaterial:e=>new I(e),createQuadRenderer:e=>new z(e)},t)}async render(e,t,r,a){const{sdrImage:i,gainMapImage:s,needsFlip:n}=await this.processImages(r,a,"from-image"),{gainMap:o,sdr:h}=this.createTextures(i,s,n);this.updateQuadRenderer(e,i,o,h,t),await e.render()}}class A extends j{load([e,t,r],a,i,s){const n=this.prepareQuadRenderer();let o,h,d;const p=async()=>{if(o&&h&&d){try{await this.render(n,d,o,h)}catch(a){return this.manager.itemError(e),this.manager.itemError(t),this.manager.itemError(r),"function"==typeof s&&s(a),void n.disposeOnDemandRenderer()}"function"==typeof a&&a(n),this.manager.itemEnd(e),this.manager.itemEnd(t),this.manager.itemEnd(r),n.disposeOnDemandRenderer()}};let m=!0,g=0,f=0,l=!0,_=0,c=0,u=!0,M=0,y=0;const w=()=>{if("function"==typeof i){i(new ProgressEvent("progress",{lengthComputable:m&&l&&u,loaded:f+c+y,total:g+_+M}))}};this.manager.itemStart(e),this.manager.itemStart(t),this.manager.itemStart(r);const x=new T(this._internalLoadingManager);x.setResponseType("arraybuffer"),x.setRequestHeader(this.requestHeader),x.setPath(this.path),x.setWithCredentials(this.withCredentials),x.load(e,async e=>{if("string"==typeof e)throw new Error("Invalid sdr buffer");o=e,await p()},e=>{m=e.lengthComputable,f=e.loaded,g=e.total,w()},t=>{this.manager.itemError(e),"function"==typeof s&&s(t)});const v=new T(this._internalLoadingManager);v.setResponseType("arraybuffer"),v.setRequestHeader(this.requestHeader),v.setPath(this.path),v.setWithCredentials(this.withCredentials),v.load(t,async e=>{if("string"==typeof e)throw new Error("Invalid gainmap buffer");h=e,await p()},e=>{l=e.lengthComputable,c=e.loaded,_=e.total,w()},e=>{this.manager.itemError(t),"function"==typeof s&&s(e)});const U=new T(this._internalLoadingManager);return U.setRequestHeader(this.requestHeader),U.setPath(this.path),U.setWithCredentials(this.withCredentials),U.load(r,async e=>{if("string"!=typeof e)throw new Error("Invalid metadata string");d=JSON.parse(e),await p()},e=>{u=e.lengthComputable,y=e.loaded,M=e.total,w()},e=>{this.manager.itemError(r),"function"==typeof s&&s(e)}),n}}class G extends j{load(e,t,a,n){const o=this.prepareQuadRenderer(),h=new T(this._internalLoadingManager);return h.setResponseType("arraybuffer"),h.setRequestHeader(this.requestHeader),h.setPath(this.path),h.setWithCredentials(this.withCredentials),this.manager.itemStart(e),h.load(e,async a=>{if("string"==typeof a)throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const h=new Uint8Array(a);let d,p,m;try{const e=await r(h);d=e.sdr,p=e.gainMap,m=e.metadata}catch(t){if(!(t instanceof i||t instanceof s))throw t;console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),m={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},d=h}try{await this.render(o,m,d.buffer,p?.buffer)}catch(t){return this.manager.itemError(e),"function"==typeof n&&n(t),void o.disposeOnDemandRenderer()}"function"==typeof t&&t(o),this.manager.itemEnd(e),o.disposeOnDemandRenderer()},a,t=>{this.manager.itemError(e),"function"==typeof n&&n(t)}),o}}export{I as GainMapDecoderMaterial,A as GainMapLoader,s as GainMapNotFoundError,G as HDRJPGLoader,G as JPEGRLoader,t as LoaderBaseShared,z as QuadRenderer,i as XMPMetadataNotFoundError,e as createDecodeFunction,W as decode,r as extractGainmapFromJPEG};
